
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/output.css">
    <title>Playing with PlantUML</title>
  </head>
  <body>
  <div class="min-h-screen bg-white">
    <div class="p-8">
      <h1 class="text-2xl p-0">The Learning Corner</h1>
    </div>
    <hr class="text-stone-200">
    
<div class="max-w-[800px] px-5 sm:px-8 py-4">
  <h1 class="text-2xl font-bold pb-4">Playing with PlantUML</h1>
  
    <div class="text-sm pb-4">March 9, 2025</div>
  
  <div class="markdown">
  <h2>Playing around with PlantUML</h2>
<p>I'm trying to understand some of the following: Nginx, networking, docker
networks, TLS, Client Server communication, server to server communication..
Playing around with PlantUML might help with that. It also has the nice side effect
of giving me some practice with PlantUML.</p>
<p><picture><source type="image/webp" srcset="/posts/playing_around_with_architecture_diagrams/bURmUuwkUs-469.webp 469w"><img src="/posts/playing_around_with_architecture_diagrams/bURmUuwkUs-469.jpeg" alt="component diagram" width="469" height="415"></picture></p>
<p>I learned that Nginx does not encrypt the packet as it is shown below. Instead
a TLS handshake is carried out between the Backend (which is the client in this case) and Keycloak, which
acts as the server. For this the client initiates a connection request to the server.</p>
<p>After completing the TCP handshake, the TLS handshake is carried out. This
involves the server sending its certificate. The certificate contains the
public key.</p>
<p>It just so happens that in this special case the certificate is the
same one that the backend also uses when requests are made to it.</p>
<p>The client in this case encrypts a pre-master secret with the servers public key and
sends it to the server. I guess this constitutes a key exchange. We have the
classic scenario here, where asymmetric encryption is used for the key
exchange, and afterwards the encryption is symmetric with the master key which
was generated by the client.</p>
<p>To recap: The client uses the servers public key which was sent within the
certificate. This public key is used by the client to encrypt a pre-master
secret which it has just generated. This means that at this point only the
client knows the pre-master secret. After it has been encrypted even the client
cannot decrypt it again. For this the private key would be necessary. The
server has the private key. This private key and the public key constitutes a
key pair. So when the server receives the encrypted pre-master secret, it can
decrypt it.</p>
<p>The client and the server, each on its own will use the decrypted pre-master
secret to derive a master secret. For this, previously exchanged random numbers
are used.</p>
<p>The below diagram will have to be updated with this new found understanding.</p>
<p><picture><source type="image/webp" srcset="/posts/playing_around_with_architecture_diagrams/wsYAWq-Pl1-631.webp 631w"><img src="/posts/playing_around_with_architecture_diagrams/wsYAWq-Pl1-631.jpeg" alt="sequence diagram" width="631" height="568"></picture></p>

  </div>
</div>

  </div>
  </body>
</html>
